/*  x86-64 UEFIアプリケーションライブラリ  for oregengo-Rコンパイラ ver 1.1 */

 const EOF      255         /* ファイルの終わりをあらわす文字コード */
 const ERROR    -1          /* エラーが発生したことをあらわす */
 const NULL     0           /* ヌルポインタ */
 const SPACE    32          /* 空白文字 */
 const CR       13          /* キャリッジリターンコード */
 const LF       10          /* ラインフィードコード */
 const PLUS     43          /* プラス記号の文字コード */
 const MINUS    45          /* マイナス記号の文字コード */
 const ESC      27          /* ESCキーの文字コード */
 const NaN      0x8000000000000000  /* ゼロ除算が発生したことをあらわす */
 const STACK_SIZE 1000
 
 // ファイル関連構造体定数
  const FILE_SIZE      0x10
  const DIR_SIZE       0x400
  const DIR_FP          0x00
  const FILE_FP         0x08
  const FILE_NAME    0x50
  const DIR_CLOSE    0x10
  const DIR_READ     0x20
  const FILE_OPEN    0x08
  const FILE_CLOSE   0x10
  const FILE_DELETE 0x18
  const FILE_READ    0x20
  const FILE_WRITE   0x28
  const FILE_FLUSH   0x50
 
 /* 作業変数 */
 char   __fbuf$(1024)
 char   __sign$(1),__nbuf$(64)
 short  __wide_str%(1024)
 char   __nallow_str$(1024)
 long   __strbuf#,__inputkey#
 long   __sys_table#
 long   __conin#,__conout#
 long   __cls#,__puts#,__getch#
 long   __boot_service#
 long   __set_wdt#,__locate_protocol#
 long   __file_sys#,__dir_open#
 long   __fbuf_length#
 count __p0#
 long   __p1#,__p2#,__p3#,__p4#,__p5#,__p6#,__p7#
 long   __t#,read_p# // data文へのポインタ
 
 // リターンスタック
 long  __stack#(STACK_SIZE)
 long  __stack_top#,__stack_p#


/* プログラム開始位置 */
_start:
/ push rbp/
/ rbp=rsp/
/ 0x10(rbp)=rcx/
/ 0x18(rbp)=rdx/

/ rax=__stack_top/
/ rdi=__stack_p/
/ (rdi)=rax/

/ rax=0x18(rbp)/
/ rdi=__sys_table/
/ (rdi)=rax/

/ rsi=0x30(rax)/
/ rdi=__conin/
/ (rdi)=rsi/

/ rcx=0x08(rsi)/
/ rdi=__getch/
/ (rdi)=rcx/

/ rsi=0x40(rax)/
/ rdi=__conout/
/ (rdi)=rsi/

/ rcx=0x30(rsi)/
/ rdi=__cls/
/ (rdi)=rcx/

/ rcx=0x08(rsi)/
/ rdi=__puts/
/ (rdi)=rcx/

/ rsi=0x60(rax)/
/ rdi=__boot_service/
/ (rdi)=rsi/

/ rcx=0x100(rsi)/
/ rdi=__set_wdt/
/ (rdi)=rcx/

/ rcx=0x140(rsi)/
/ rdi=__locate_protocol/
/ (rdi)=rcx/
/ rax=rcx/
/ rcx=__file_sys_guid/
/ rdx=0/
/ r8=__file_sys/
/ call (rax)/

/ rdi=__file_sys/
/ rsi=(rdi)/
/ rcx=0x08(rsi)/
/ rdi=__dir_open/
/ (rdi)=rcx/

/ rcx=0/
/ rdx=0/
/ r8=0/
/ r9=0/
/ rax=__set_wdt/
/ call (rax)/

// メイン関数を呼び出したあとループ
 main
__start1:
  goto __start1


// ファイルシステムプロトコルのガイド
__file_sys_guid:
 data  0x11d26459964e5b22
 data  0x3b7269c9a000398e


// r13で示す文字列を表示して、r14のデータを表示する(デバッグ用)
print_status:
 long  __status#,__rdi#,__rsi#,__rcx#,__rdx#
/ rax=__status/
/ (rax)=r14/
/ rax=__rdi/
/ (rax)=r15/
/ rax=__rsi/
/ (rax)=rsi/
/ rax=__rcx/
/ (rax)=rcx/
/ rax=__rdx/
/ (rax)=rdx/

/ rdi=r13/
 prints nl
 "status=", prints __status#, printd nl

/ rax=__rdi/
/ rdi=(rax)/
/ rax=__rsi/
/ rsi=(rax)/
/ rax=__rcx/
/ rcx=(rax)/
/ rax=__rdx/
/ rdx=(rax)/
  end


// r13で示す文字列を表示して、r14で示すアドレスのデータをダンプ表示する(デバッグ用)
dump:
 long __adrs#,__r8#,__r9#
 count __ii#,__jj#,__kk#

/ rax=__adrs/
/ (rax)=r14/
/ rax=__rdi/
/ (rax)=rdi/
/ rax=__rsi/
/ (rax)=rsi/
/ rax=__rcx/
/ (rax)=rcx/
/ rax=__rdx/
/ (rax)=rdx/
/ rax=__r8/
/ (rax)=r8/
/ rax=__r9/
/ (rax)=r9/

/ rdi=r13/ 
  prints nl
  for __ii#=0 to 32 step 16
    __adrs#, __ii#, + hex prints ": ", prints
    for __jj#=0 to 15
      __ii#,  __jj#, + __adrs#, + __kk#=
      (__kk)$, hex prints " ", prints
    next __jj#
    nl
  next __ii#
  nl nl nl nl nl
    
/ rax=__rdi/
/ rdi=(rax)/
/ rax=__rsi/
/ rsi=(rax)/
/ rax=__rcx/
/ rcx=(rax)/
/ rax=__rdx/
/ rdx=(rax)/
/ rax=__r8/
/ r8=(rax)/
/ rax=__r9/
/ r9=(rax)/
  end


// ワイド文字列に変換する
_wide:
  __p1#=
  0, __p2#= __wide_str%(0)=
__wide1:
  (__p1)$(__p2#), __t#= __wide_str%(__p2#)= 
  __p2#, 1, + __p2#=
  if __t#<>0 goto __wide1
  __wide_str, return


// ワイド文字列を通常文字列に変換する
_nallow:
  __p1#=
  0, __p2#= __nallow_str$(0)=
__nallow1:
  (__p1)%(__p2#),  __t#= __nallow_str$(__p2#)= 
  __p2#, 1, + __p2#=
  if __t#<>0 goto __nallow1
  __nallow_str, return


// 画面クリア
cls:
/ rsi=__conout/
/ rcx=(rsi)/
/ rsi=__cls/
/ rax=(rsi)/
/ call (rax)/
  end


// キーボードからからキーコードを読み込む 
getkey:
/ rdx=__inputkey/
/ rsi=__conin/
/ rcx=(rsi)/
/ rsi=__getch/
/ rax=(rsi)/
/ call (rax)/
/ rax=0/
/ rsi=__inputkey/
/ rdi=(rsi)/
/ rdi&rdi/
/ jz getkey/
 end


// コンソールからから一文字読み込む 
getchar:
/ rdx=__inputkey/
/ rsi=__conin/
/ rcx=(rsi)/
/ rsi=__getch/
/ rax=(rsi)/
/ call (rax)/
/ rax=0/
/ rsi=__inputkey+2/
/ rax=(rsi)/
/ rdi=0xff/
/ rdi&=rax/
/ jz getchar/
 end


/* ファイルから一文字読み込む( fp, getc ch$= ) */
getc:
  __t#=
  if __t#=0 goto getchar
  0, __fbuf$=
  1, __fbuf, __t#, _read __t#=
  if __t#=0 then EOF, return
  __fbuf$, return


/* ファイルから読み込む( size, buf, fp, _read ),戻り値は読み込んだバイト数 */
_read:
/ rcx=FILE_FP(rdi)/
/ rax=rdx/
/ rdx=__fbuf_length/
/ (rdx)=rax/
/ r8=rsi/
/ rax=FILE_READ(rcx)/
/ call (rax)/

// r13="_read"/ 
// r14=rax/
// print_status

/ rax=__fbuf_length/
/ rdi=(rax)/
  end


// コンソールへ1文字出力する
putchar:
  __strbuf#=
/ rdx=__strbuf/
/ rsi=__conout/
/ rcx=(rsi)/
/ rsi=__puts/
/ rax=(rsi)/
/ call (rax)/
 end 


/* ファイルへ一文字書き込む( ch, fp, putc ) */
putc:
  __t#= pop __fbuf$=
  if __t#=1 then __fbuf$, gotoputchar
  0, __fbuf$(1)=
  1, __fbuf, __t#, _write
  return


/* ファイルへ書き込む( size, buf, fp, _write ) ,戻り値は書き込んだバイト数 */
_write:

/ rcx=FILE_FP(rdi)/
/ rax=rdx/
/ rdx=__fbuf_length/
/ (rdx)=rax/
/ r8=rsi/
/ rax=FILE_WRITE(rcx)/
/ call (rax)/

// r13="_write"/ 
// r14=rax/
// print_status

/ rax=__fbuf_length/
/ rdi=(rax)/
 end


// 書き込みモードでファイルを開く
wopen:
/ rdx=0x8000000000000003/
/ jmp open/


// 読み出しモードでファイルを開く
ropen:
/ rdx=1/


// ファイルを開く (mode, fname, hfile, open)
open:
  long __fp#,__mode#,__name#,__dir_fp#,__file_fp#,__file_open#

/ rax=0x100/
/ rsp-=rax/

/ rax=__fp/
/ (rax)=rdi/
/ rax=__mode/
/ (rax)=rdx/
/ rdi=rsi/
  _wide
/ rax=__name/
/ rdi=__wide_str/
/ (rax)=rdi/

/ rdx=__fp/
/ rdx=(rdx)/
/ rax=DIR_FP/
/ rdx+=rax/
/ rax=__dir_fp/
/ (rax)=rdx/

/ rdx=__fp/
/ rdx=(rdx)/
/ rax=FILE_FP/
/ rdx+=rax/
/ rax=__file_fp/
/ (rax)=rdx/

/ rdi=__file_sys/
/ rcx=(rdi)/
/ rdx=__dir_fp/
/ rax=__dir_open/
/ rax=(rax)/
/ call (rax)/
/ rax&rax/
/ jnz open_error/

// r13="dir_open"/ 
// r14=rax/
// print_status

// r13="dir_fp"/ 
// rcx=__dir_fp/
// r14=(rcx)/
// dump

// r13="fp1"/ 
// r14=fp/
// dump

/ rcx=__dir_fp/
/ rcx=(rcx)/
/ rcx=FILE_OPEN(rcx)/
/ rax=__file_open/
/ (rax)=rcx/
/ rcx=__dir_fp/
/ rcx=(rcx)/
/ rdx=__file_fp/
/ rdx=(rdx)/
/ rdi=__name/
/ r8=(rdi)/
/ rdi=__mode/
/ r9=(rdi)/
/ rdi=0/
/ 0x20(rsp)=rdi/
/ rax=__file_open/
/ rax=(rax)/
/ call (rax)/
/ rax&rax/
/ jnz open_error/

// r13="file open"/ 
// r14=rax/
// print_status

// r13="fp2"/ 
// r14=fp/
// dump

/ rax=0x100/
/ rsp+=rax/
  0,  end 

// エラー終了
open_error:
/ rax=0x100/
/ rsp+=rax/
  -1, end
 
 
/* ファイルを閉じる */
rclose:
 long __t2#
 
/ rax=__t2/
/ (rax)=rdi/
/ rcx=FILE_FP(rdi)/

// r13="file_fp"/
// r14=rcx/
// dump

/ rax=FILE_CLOSE(rcx)/
/ call (rax)/

// r13="file close"/ 
// r14=rax/
// print_status

/ rcx=__dir_fp/
/ rcx=(rcx)/
/ rax=DIR_CLOSE(rcx)/
/ call (rax)/

// r13="dir close"/ 
// r14=rax/
// print_status
 end

 
/* ファイルを閉じる */
wclose:
 long __t3#
 
/ rax=__t3/
/ (rax)=rdi/
/ rcx=FILE_FP(rdi)/
/ rax=FILE_FLUSH(rcx)/
/ call (rax)/

// r13="file flush"/ 
// r14=rax/
// print_status

/ rax=__t3/
/ rdi=(rax)/
/ rcx=FILE_FP(rdi)/
/ rax=FILE_CLOSE(rcx)/
/ call (rax)/

// r13="file close"/ 
// r14=rax/
// print_status

/ rcx=__dir_fp/
/ rcx=(rcx)/
/ rax=DIR_CLOSE(rcx)/
/ call (rax)/

// r13="dir close"/ 
// r14=rax/
// print_status
end

 
/* ファイルを消去する */
delete:
  long __t4#

/ rax=__t4/
/ (rax)=rdi/
/ rcx=FILE_FP(rdi)/

// r13="file_fp"/
// r14=rcx/
// dump

/ rax=FILE_DELETE(rcx)/
/ call (rax)/

// r13="file delete"/ 
// r14=rax/
// print_status

/ rcx=__dir_fp/
/ rcx=(rcx)/
/ rax=DIR_CLOSE(rcx)/
/ call (rax)/

// r13="dir close"/ 
// r14=rax/
// print_status
 end

 
// ディレクトリを開く (fp, dopen)
dopen:
/ rdx=__fp/
/ (rdx)=rdi/
/ rdx=(rdx)/
/ rax=DIR_FP/
/ rdx+=rax/
/ rax=__dir_fp/
/ (rax)=rdx/

/ rdi=__file_sys/
/ rcx=(rdi)/
/ rdx=__dir_fp/
/ rax=__dir_open/
/ rax=(rax)/
/ call (rax)/
/ rax&rax/
/ jnz dopen_error/

// r13="dir_open"/ 
// r14=rax/
// print_status

// r13="dir_fp"/ 
// rcx=__dir_fp/
// r14=(rcx)/
// dump
   0, end 

// エラー終了
dopen_error:
   -1, end 
 
 
/* ディレクトリを閉じる */
dclose:
/ rcx=__dir_fp/
/ rcx=(rcx)/
/ rax=DIR_CLOSE(rcx)/
/ call (rax)/

// r13="dir close"/ 
// r14=rax/
// print_status
 end

 
/* ディレクトリ情報を読み込む ( buf, dread : 戻り値がゼロなら終わり) */
dread:
/ rsi=__p1/
/ (rsi)=rdi/
/ rcx=__dir_fp/
/ rcx=(rcx)/
/ rdx=__fbuf_length/
/ rax=DIR_SIZE/
/ (rdx)=rax/
/ rsi=__p1/
/ r8=(rsi)/
/ rax=DIR_READ(rcx)/
/ call (rax)/

// r13="dir read"/ 
// r14=rax/
// print_status

/ rdi=__fbuf_length/
/ rdi=(rdi)/
 end

 
/* 文字列を表示する */
prints:
 1,


/* 文字列をファイルへ出力する */
fprints:
 __p7#= swap __p6#=
 __fprints1:
  if (__p6)$=NULL then NULL, end
  (__p6)$, __p7#, putc __p5#=
  if __p5#=ERROR then ERROR, end
  __p6#, 1, + __p6#=
 goto __fprints1


/* 数値を表示する */
printd:
 1,


// 数値をファイルに出力する 
fprintd:
 __p7#= swap dec __p7#, fprints
 end


/* 改行する */
nl:
 13, putchar 10, putchar
 end


// 改行コードをファイルに出力する
fnl:
 __p7#=
 LF, __p7#, putc
 end


// コンソールから文字列を入力する
inputs:
 0,


// ファイルから文字列を入力する
finputs:
 __p7#= swap __p6#=
 __finputs1:
  __p7#, getc __p5$=
  if __p5$=CR   goto __finputs2
  if __p5$=LF    goto __finputs2
  if __p5$=EOF goto __finputs2
  __p5$, (__p6)$=
  __p6#, 1, + __p6#=
 goto __finputs1
 __finputs2:
 NULL,  (__p6)$=
 __p5$, end


/* 文字列を比較する */
strcmp:
 __p2#= swap __p1#=
 __strcmp1:
  if (__p1)$<>(__p2)$ then 1, end
  if (__p1)$=NULL then 0, end
  __p1#, 1, + __p1#=
  __p2#, 1, + __p2#=
 goto __strcmp1


/* 文字列をコピーする */
strcpy:
 __p2#= swap __p1#=
 __strcpy1:
  (__p1)$, (__p2)$= __p3#=
  __p1#, 1, + __p1#=
  __p2#, 1, + __p2#=
 if __p3#<>NULL goto __strcpy1
 end


/* 文字列を連結する */
strcat:
 __p2#= swap __p1#=
__strcat1:
 if (__p2)$<>NULL then __p2#, 1, + __p2#= goto__strcat1
__strcat2:
 (__p1)$, (__p2)$= __p3#=
 __p1#, 1, + __p1#=
 __p2#, 1, + __p2#=
 if __p3#<>NULL goto __strcat2
 end


/* 文字列を検索する */
strstr:
 __p2#= swap __p1#=
__strstr1:
 if (__p1)$=NULL then NULL, end
 __p1#, __p3#=
 __p2#, __p4#=
__strstr2:
 if (__p3)$<>(__p4)$ then __p1#, 1, + __p1#= goto__strstr1
 __p3#, 1, + __p3#=
 __p4#, 1, + __p4#=
 if (__p4)$<>NULL goto __strstr2
 __p1#, end


/* 文字列の長さを得る */
strlen:
 __p1!=
 0, __p2#=
__strlen1:
 if (__p1)$=NULL then __p2#, end
 __p1#, 1, + __p1#=
 __p2#, 1, + __p2#=
 goto __strlen1


/* 文字列を数値に変換する(基数指定あり) */
atoi:
 __p2#= swap __p1#=
 1, __p3#=   0, __p4#=
 if (__p1)$=PLUS  then __p1#, 1, + __p1#=
 if (__p1)$=MINUS then __p1#, 1, + __p1#= -1, __p3#=
__atoi1:
 0, __p5#=
__atoi2:
 if __p5#>=__p2# then __p3#, __p4#, * end
 if "0123456789abcdef"$(__p5#)<>(__p1)$ then __p5#, 1, + __p5#= goto__atoi2
 __p4#, __p2#, umul __p5#, + __p4#=
 __p1#, 1, + __p1#=
 goto __atoi1


/* 数値を文字列に変換する(基数指定あり) */
itoa:
  __p2#= swap __p1#=
  if __p1#=0 then "0", __nbuf, strcpy __nbuf, end
  __nbuf, __p3#=
  1,      __p4#=
  __p1#,  __p5#=
__itoa1:
 if __p5#<__p2# goto __itoa2
  __p5#, __p2#, udiv __p5#=
  __p4#, __p2#, umul __p4#=
  goto __itoa1
__itoa2:
  __p1#, __p4#, udiv __p5#=
  __p4#, __p5#, umul __p1#, swap - __p1#=
  "0123456789abcdef"$(__p5#),  (__p3)$=
  __p3#, 1, + __p3#=
  __p4#, __p2#, udiv __p4#=
  if __p4#<>0 goto __itoa2
 NULL, (__p3)$=
 __nbuf, end


/* 数値を2進文字列に変換する */
bin:
 2, itoa end


/* 数値を8進文字列に変換する */
oct:
 8, itoa end


/* 数値を10進文字列に変換する */
dec:
 __p1#=
 if __p1#>=0 then __p1#, 10, itoa end
 __p1#,  neg 10, itoa
 MINUS,  __sign$=
 __sign, end


/* 数値を16進文字列に変換する */
hex:
 16, itoa end


/* read文の読み込み位置を設定する */
restore:
 read_p#=
 end


/* data文で与えられたデータを読み込む */
read:
 read_p#, 8, + read_p#=
 (read_p)#(-1), end


/* 数値の絶対値を求める */
abs:
  __p1#=
  if __p1#>=0 then __p1#, end
  0, __p1#, - end

